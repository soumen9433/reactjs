"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// import from npm
var Promise = require("bluebird");
require("core-js");
var lodash_1 = require("lodash");
/**
 * map for script names against utility objects
 * @type {Map<string, ScriptState>}
 */
exports.loadedScripts = new Map();
/**
 * script tags to be generated by the cache method
 * @type {{}}
 */
exports.scriptTags = {};
/**
 *
 * @param scripts {Scripts} - An object with all the scripts required. Keys are script names, values are URLs.
 */
function cache(scripts) {
    lodash_1.forEach(scripts, (script, name) => {
        lodash_1.assignIn(exports.scriptTags, {
            [name]: {
                name,
                onLoad: onLoad.bind(null, name),
                script,
                tag: getScript(script, name)
            }
        });
    });
}
exports.cache = cache;
function getScriptStub(name) {
    return exports.scriptTags[name];
}
exports.getScriptStub = getScriptStub;
/**
 * Callback to be fired when each script has loaded.
 * @param name {string} - The name of the string that has just loaded.
 */
function onLoad(name, callback) {
    const stored = exports.loadedScripts.get(name);
    if (stored.hasLoaded) {
        callback(null, stored);
    }
    else if (stored) {
        stored.promise.then(() => {
            stored.wasRejected ? callback(stored.error) : callback(null, stored);
        });
    }
}
exports.onLoad = onLoad;
/**
 * Callback to be fired when all scripts have loaded
 * @param callback {Function} - The callback to be executed.
 */
function onAllLoad(callback) {
    const promises = [];
    const results = [];
    exports.loadedScripts.forEach((value) => {
        if (value.hasLoaded) {
            results.push(value);
        }
        else {
            promises.push(value.promise);
        }
    });
    if (promises.length > 0) {
        Promise.all(promises)
            .then((res) => callback(null, res))
            .catch((errs) => callback(errs, null));
    }
    else {
        callback(null, results);
    }
}
exports.onAllLoad = onAllLoad;
/**
 * Get a script from a remote location.
 * @param name {string} - The name of the script to be retrieved.
 * @param url {string} - The URL/location of the script to be retrieved.
 */
function getScript(url, name) {
    if (!exports.loadedScripts.has(name) && !document.querySelector(`script[src="${url}"]`)) {
        const tag = document.createElement("script");
        const promise = new Promise((resolve, reject) => {
            const body = document.getElementsByTagName("body")[0];
            // make sure the script type is javascript
            // and that scripts are loaded in order using
            // the "async" option
            lodash_1.assignIn(tag, {
                async: false,
                type: "text/javascript"
            });
            function handleResult(event) {
                const stored = exports.loadedScripts.get(name);
                if (event.type === "load") {
                    stored.hasLoaded = true;
                    resolve(stored);
                }
                else if (event.type === "error") {
                    stored.wasRejected = true;
                    reject(stored.error);
                }
            }
            // add load and error event listeners
            tag.addEventListener("load", handleResult);
            tag.addEventListener("error", handleResult);
            lodash_1.assignIn(tag, { src: url });
            body.appendChild(tag);
        });
        const scriptObject = {
            hasLoaded: false,
            promise,
            tag,
            wasRejected: false
        };
        exports.loadedScripts.set(name, scriptObject);
    }
    return exports.loadedScripts.get(name);
}
exports.getScript = getScript;
// also make cache the default export
exports.default = cache;
